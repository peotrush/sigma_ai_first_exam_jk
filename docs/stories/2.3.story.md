# Story 2.3: Transaction Model & Database Schema

**Epic:** 2 - QR Receipt Scanning & Transaction Management
**Status:** Draft
**Created:** 2025-11-17
**Dependencies:** Story 1.3 (Authentication)

---

## Story Statement

As a **developer**,
I want **to create the Transaction entity and database schema**,
so that **transactions can be persisted and retrieved via REST API**.

---

## Acceptance Criteria

1. Transaction entity/model created with fields: id, userId, amount, timestamp, category (nullable), location (nullable), source (qr_scan | manual), createdAt, updatedAt
2. Database migration created and applied to create transactions table
3. Transaction entity includes validation: amount > 0, timestamp is valid date, source is enum
4. TypeORM entity properly configured with relationships to User entity
5. POST /transactions endpoint creates new transaction associated with authenticated user
6. Transactions are stored with original timestamp from receipt (not current time)
7. GET /transactions endpoint returns user's transactions ordered by timestamp descending
8. GET /transactions supports pagination: query params `?limit=20&offset=0`
9. Transaction list endpoint includes total count for pagination UI
10. All transaction endpoints require authentication (401 if not authenticated)

---

## Dev Notes

### Previous Story Insights
- Story 1.3 established authentication with JWT tokens
- User entity exists with proper TypeORM configuration
- Database connection (PostgreSQL) is working
- All endpoints use @UseGuards(JwtAuthGuard) for authentication
- Repository pattern used for database access

### Database & Entity Architecture
**Source: docs/architecture.md#Data Models**

- **Database:** PostgreSQL 14+ with ACID compliance
- **ORM:** TypeORM 0.3.17 (currently in use)
- **Pattern:** Repository pattern for data access
- **Relationships:** One-to-Many (User → Transactions)

### Transaction Entity Specification

**Fields:**
```typescript
- id: UUID (primary key, auto-generated)
- userId: UUID (foreign key to users table)
- amount: Decimal (numeric with 2 decimal places for BGN currency)
- timestamp: DateTime (original receipt date/time, not creation time)
- category: String (nullable - will be filled by categorization service later)
- location: Point/GeoJSON (nullable - will be filled by GPS service later)
- source: Enum ('qr_scan' | 'manual')
- createdAt: DateTime (auto-generated)
- updatedAt: DateTime (auto-updated)
```

**Validation Rules:**
- amount: Must be positive (> 0), max 2 decimal places
- timestamp: Must be valid date, cannot be in future
- source: Must be one of: 'qr_scan', 'manual'
- category: Optional, max 50 characters
- userId: Required, must exist in users table

**Database Table Name:** transactions

**Indices:**
- userId + timestamp (for efficient user history queries)
- userId + createdAt (for pagination)

### API Endpoints

**Create Transaction**
```
POST /transactions
Authorization: Bearer {jwt_token}
Content-Type: application/json

Request Body:
{
  "amount": 42.50,
  "timestamp": "2025-11-17T14:30:00Z",
  "source": "qr_scan",
  "category": null,
  "location": null
}

Response (201 Created):
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "userId": "user-uuid-here",
  "amount": 42.50,
  "timestamp": "2025-11-17T14:30:00Z",
  "source": "qr_scan",
  "category": null,
  "location": null,
  "createdAt": "2025-11-17T15:00:00Z",
  "updatedAt": "2025-11-17T15:00:00Z"
}

Error (401 Unauthorized):
{
  "statusCode": 401,
  "message": "Unauthorized"
}

Error (400 Bad Request):
{
  "statusCode": 400,
  "message": "Validation failed",
  "errors": ["amount must be a positive number"]
}
```

**Get User Transactions (Paginated)**
```
GET /transactions?limit=20&offset=0
Authorization: Bearer {jwt_token}

Response (200 OK):
{
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "userId": "user-uuid-here",
      "amount": 42.50,
      "timestamp": "2025-11-17T14:30:00Z",
      "source": "qr_scan",
      "category": null,
      "location": null,
      "createdAt": "2025-11-17T15:00:00Z",
      "updatedAt": "2025-11-17T15:00:00Z"
    }
  ],
  "pagination": {
    "limit": 20,
    "offset": 0,
    "total": 1,
    "hasMore": false
  }
}
```

### File Locations
- **Entity:** `apps/api/src/transactions/entities/transaction.entity.ts`
- **DTO:** `apps/api/src/transactions/dto/create-transaction.dto.ts`
- **DTO:** `apps/api/src/transactions/dto/transaction.dto.ts`
- **Service:** `apps/api/src/transactions/transactions.service.ts`
- **Controller:** `apps/api/src/transactions/transactions.controller.ts`
- **Repository:** `apps/api/src/transactions/repositories/transaction.repository.ts`
- **Migration:** `apps/api/src/database/migrations/{timestamp}-CreateTransactionsTable.ts`
- **Tests:** `apps/api/src/transactions/transactions.service.spec.ts`
- **Tests:** `apps/api/src/transactions/transactions.controller.spec.ts`

### TypeORM Configuration Reference
**Source: docs/architecture.md#Backend Architecture**

Using existing pattern from User entity:
- @Entity decorator
- @PrimaryGeneratedColumn('uuid')
- @Column with appropriate types
- @ManyToOne relationship to User
- @CreateDateColumn and @UpdateDateColumn
- Proper nullable configuration

Example from User entity pattern:
```typescript
@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ type: 'varchar', length: 255, unique: true })
  email: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

### API Module Structure
**Source: docs/architecture.md#NestJS Patterns**

Standard NestJS module structure:
- Module class with @Module() decorator
- Service class with business logic
- Controller class with route handlers
- DTO classes for validation
- Repository (optional, for complex queries)
- Spec files for unit tests

### Testing Requirements
**Source: Story 1.4 (CI/CD Pipeline)**

- Unit tests for TransactionService (CRUD operations)
- Unit tests for TransactionController (HTTP endpoints)
- Mock repositories and services
- Use @nestjs/testing TestingModule
- Tests should cover:
  - Create transaction with valid data
  - Create transaction with invalid amount (validation)
  - Create transaction with future timestamp (validation)
  - Get transactions for user (pagination)
  - Get transactions with offset
  - Unauthorized access returns 401
  - Category and location nullable handling

### Database Migration Strategy
- Use TypeORM CLI to generate migration
- Migration creates transactions table with proper indices
- Support rollback if needed
- No data loss (greenfield deployment)

---

## Tasks / Subtasks

### Task 1: Create Transaction Entity (AC: 1, 3)
- Create `apps/api/src/transactions/entities/transaction.entity.ts`
- Define Transaction entity with TypeORM decorators
- Fields: id (uuid), userId (fk), amount (decimal), timestamp (datetime), category (nullable), location (nullable), source (enum), createdAt, updatedAt
- Add validation constraints in entity
- Add relationship: @ManyToOne with User entity
- Add indices for userId+timestamp and userId+createdAt
- Generate migration using TypeORM CLI
- Apply migration to database

**Acceptance:** Entity file created, migration generated, database table exists with correct schema

### Task 2: Create DTOs (AC: 1, 3)
- Create `apps/api/src/transactions/dto/create-transaction.dto.ts`
- Create `apps/api/src/transactions/dto/transaction.dto.ts`
- Use class-validator decorators for validation
- CreateTransactionDTO: amount (IsPositive), timestamp (IsDate, cannot be future), source (IsEnum), category (IsOptional), location (IsOptional)
- TransactionDTO: all fields with description comments
- Source enum: 'qr_scan' | 'manual'

**Acceptance:** DTOs created with proper validation decorators

### Task 3: Create Service (AC: 2, 5, 6, 9)
- Create `apps/api/src/transactions/transactions.service.ts`
- Implement create(userId, createTransactionDTO): Promise<Transaction>
  - Validate DTO
  - Create transaction with provided timestamp (not current time)
  - Associate with user
  - Save to database
  - Return transaction
- Implement getByUser(userId, limit, offset): Promise<{data, pagination}>
  - Query transactions for user
  - Order by timestamp DESC
  - Apply limit and offset
  - Return total count
  - Handle edge cases (negative offset, limit > max)
- Add logging for errors

**Acceptance:** Service methods implemented and working

### Task 4: Create Controller (AC: 5, 7, 8, 10)
- Create `apps/api/src/transactions/transactions.controller.ts`
- POST /transactions endpoint
  - @UseGuards(JwtAuthGuard)
  - Accept CreateTransactionDTO
  - Call service.create(userId, dto)
  - Return 201 Created with transaction
  - Return 400 Bad Request on validation error
- GET /transactions endpoint
  - @UseGuards(JwtAuthGuard)
  - Accept @Query('limit', 'offset') with defaults (limit=20, offset=0)
  - Call service.getByUser(userId, limit, offset)
  - Return 200 OK with data and pagination
  - Return 401 Unauthorized if no valid JWT

**Acceptance:** Controller endpoints working correctly

### Task 5: Create Module (AC: 2, 4, 5)
- Create `apps/api/src/transactions/transactions.module.ts`
- Import TypeOrmModule with Transaction entity
- Register TransactionRepository
- Declare TransactionService
- Declare TransactionController
- Import JwtModule if needed for guard
- Update app.module.ts to import TransactionsModule

**Acceptance:** Module properly configured and registered

### Task 6: Unit Tests - Service (AC: 3, 8)
- Create `apps/api/src/transactions/transactions.service.spec.ts`
- Test create() with valid data
- Test create() with invalid amount (negative, zero)
- Test create() with future timestamp (should fail validation)
- Test create() with missing userId
- Test getByUser() returns transactions ordered by timestamp DESC
- Test getByUser() with pagination (limit, offset)
- Test getByUser() returns total count
- Mock TransactionRepository
- All tests must pass: `npm run test --workspace=apps/api`

**Acceptance:** Service tests all passing, coverage > 80%

### Task 7: Unit Tests - Controller (AC: 5, 10)
- Create `apps/api/src/transactions/transactions.controller.spec.ts`
- Test POST /transactions with valid data returns 201
- Test POST /transactions with invalid DTO returns 400
- Test POST /transactions without JWT returns 401
- Test GET /transactions returns transactions with pagination
- Test GET /transactions with custom limit/offset
- Test GET /transactions without JWT returns 401
- Mock TransactionService
- All tests must pass: `npm run test --workspace=apps/api`

**Acceptance:** Controller tests all passing, coverage > 80%

### Task 8: Integration Test (AC: 2, 5, 6, 7)
- Create `apps/api/src/transactions/transactions.integration.spec.ts` (or use e2e)
- Test full flow: create transaction → retrieve it
- Test create with different sources (qr_scan, manual)
- Test pagination across multiple transactions
- Use actual database or seed data
- Verify timestamps are stored correctly

**Acceptance:** Integration tests passing

### Task 9: Database Verification (AC: 2, 4)
- Run migration: `npm run migration:run --workspace=apps/api`
- Verify table structure: `SELECT * FROM information_schema.columns WHERE table_name='transactions'`
- Verify indices exist
- Test connection with TypeORM datasource
- Verify nullable columns are optional
- Document any adjustments needed

**Acceptance:** Database table created correctly with all fields and indices

### Task 10: API Testing (AC: 5, 7, 9, 10)
- Test with cURL or REST client (Postman, Insomnia, VSCode REST)
- Test POST /transactions with valid data → expect 201
- Test POST /transactions without JWT → expect 401
- Test POST /transactions with invalid amount → expect 400
- Test GET /transactions with JWT → expect 200 with data
- Test GET /transactions pagination → verify limit/offset work
- Test GET /transactions without JWT → expect 401
- Document endpoints in README or API docs
- Ensure all AC 5, 7, 9, 10 are satisfied

**Acceptance:** All endpoints working correctly via HTTP requests

---

## Project Structure Notes

Current monorepo structure aligns with architecture:

```
kash-budget/
├── apps/
│   ├── api/
│   │   ├── src/
│   │   │   ├── transactions/          # NEW: Transaction feature
│   │   │   │   ├── entities/
│   │   │   │   │   └── transaction.entity.ts
│   │   │   │   ├── dto/
│   │   │   │   │   ├── create-transaction.dto.ts
│   │   │   │   │   └── transaction.dto.ts
│   │   │   │   ├── repositories/
│   │   │   │   │   └── transaction.repository.ts
│   │   │   │   ├── transactions.controller.ts
│   │   │   │   ├── transactions.service.ts
│   │   │   │   ├── transactions.module.ts
│   │   │   │   ├── transactions.service.spec.ts
│   │   │   │   └── transactions.controller.spec.ts
│   │   │   ├── database/
│   │   │   │   ├── migrations/
│   │   │   │   │   └── {timestamp}-CreateTransactionsTable.ts
│   │   │   ├── auth/                  # ✅ Exists (Story 1.3)
│   │   │   ├── health/                # ✅ Exists (Story 1.2)
│   │   │   ├── app.module.ts          # UPDATE: Import TransactionsModule
│   │   │   └── main.ts
│   │   ├── nest-cli.json
│   │   └── package.json
├── packages/
│   └── shared/
└── package.json
```

No conflicts with architecture. Transaction feature follows NestJS patterns established in auth and health modules.

---

## Dev Agent Record

### Implementation Notes
*(To be filled during implementation)*

### Challenges & Solutions
*(To be documented during implementation)*

### Testing Summary
*(To be documented during implementation)*

---

## References

- **Architecture Document:** [docs/architecture.md#Data Models]
- **Story 1.3:** Authentication system (User entity, JwtAuthGuard)
- **Story 1.2:** Database setup and connection
- **Story 1.4:** CI/CD pipeline (testing with Jest)
- **TypeORM Documentation:** https://typeorm.io/
- **NestJS Database Documentation:** https://docs.nestjs.com/techniques/database
- **NestJS Validation:** https://docs.nestjs.com/techniques/validation
- **PostgreSQL Data Types:** https://www.postgresql.org/docs/14/datatype.html
